<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>세균전 관세전쟁</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        .board {
            display: grid;
            gap: 2px;
            background-color: #ccc;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .cell {
            width: 55px;
            height: 55px;
            background-color: #fff;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        .cell:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        .usa {
            background-color: #3c3b6e;
            border-radius: 50%;
            position: relative;
        }
        .usa::after {
            content: "USA";
            position: absolute;
            color: white;
            font-size: 12px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .china {
            background-color: #de2910;
            position: relative;
        }
        .china::after {
           content: "★";
           position: absolute;
           color: #ffde00;
           font-size: 24px;
        }
        .wall {
            background-color: #555;
            position: relative;
        }
        .wall::before {
            content: "";
            position: absolute;
            width: 70%;
            height: 70%;
            background-color: #333;
            top: 15%;
            left: 15%;
        }
        .visited {
            background-color: #f0f0f0;
            position: relative;
            pointer-events: none;
        }
        .visited::after {
            content: "X";
            color: #999;
            font-size: 18px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .panel {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 250px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover:not(:disabled) {
            background-color: #45a049;
            transform: scale(1.05);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #message {
            margin: 10px 0;
            min-height: 20px;
            color: #d9534f;
        }
        #gameRules {
            margin-top: 20px;
            text-align: left;
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .lastMove {
            box-shadow: inset 0 0 0 3px yellow;
        }
        #turnCounter {
            font-weight: bold;
            color: #333;
            margin-top: 10px;
        }
        .map-selection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .map-option {
            width: 120px;
            height: 100px;
            border: 2px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 5px;
        }
        .map-option:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
        }
        .map-option.selected {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
        }
        .map-preview {
            width: 100px;
            height: 70px;
            margin-bottom: 5px;
            background-color: #ccc;
            position: relative;
        }
        .map-preview-5x5 {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="70" viewBox="0 0 100 70"><rect x="5" y="5" width="90" height="60" fill="white" stroke="gray" stroke-width="1"/><line x1="5" y1="17" x2="95" y2="17" stroke="gray" stroke-width="1"/><line x1="5" y1="29" x2="95" y2="29" stroke="gray" stroke-width="1"/><line x1="5" y1="41" x2="95" y2="41" stroke="gray" stroke-width="1"/><line x1="5" y1="53" x2="95" y2="53" stroke="gray" stroke-width="1"/><line x1="23" y1="5" x2="23" y2="65" stroke="gray" stroke-width="1"/><line x1="41" y1="5" x2="41" y2="65" stroke="gray" stroke-width="1"/><line x1="59" y1="5" x2="59" y2="65" stroke="gray" stroke-width="1"/><line x1="77" y1="5" x2="77" y2="65" stroke="gray" stroke-width="1"/></svg>');
        }
        .map-preview-8x8 {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="70" viewBox="0 0 100 70"><rect x="5" y="5" width="90" height="60" fill="white" stroke="gray" stroke-width="1"/><line x1="5" y1="12.5" x2="95" y2="12.5" stroke="gray" stroke-width="1"/><line x1="5" y1="20" x2="95" y2="20" stroke="gray" stroke-width="1"/><line x1="5" y1="27.5" x2="95" y2="27.5" stroke="gray" stroke-width="1"/><line x1="5" y1="35" x2="95" y2="35" stroke="gray" stroke-width="1"/><line x1="5" y1="42.5" x2="95" y2="42.5" stroke="gray" stroke-width="1"/><line x1="5" y1="50" x2="95" y2="50" stroke="gray" stroke-width="1"/><line x1="5" y1="57.5" x2="95" y2="57.5" stroke="gray" stroke-width="1"/><line x1="16.25" y1="5" x2="16.25" y2="65" stroke="gray" stroke-width="1"/><line x1="27.5" y1="5" x2="27.5" y2="65" stroke="gray" stroke-width="1"/><line x1="38.75" y1="5" x2="38.75" y2="65" stroke="gray" stroke-width="1"/><line x1="50" y1="5" x2="50" y2="65" stroke="gray" stroke-width="1"/><line x1="61.25" y1="5" x2="61.25" y2="65" stroke="gray" stroke-width="1"/><line x1="72.5" y1="5" x2="72.5" y2="65" stroke="gray" stroke-width="1"/><line x1="83.75" y1="5" x2="83.75" y2="65" stroke="gray" stroke-width="1"/></svg>');
        }
        .map-preview-usa {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="70" viewBox="0 0 100 70"><path d="M10,10 L90,10 L90,20 L80,20 L80,30 L70,30 L70,40 L80,40 L80,50 L70,50 L70,60 L10,60 Z" fill="white" stroke="gray" stroke-width="1"/></svg>');
        }
        .map-preview-china {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="70" viewBox="0 0 100 70"><path d="M30,10 L70,10 C85,10 90,30 90,40 C90,50 85,60 70,60 L30,60 C15,60 10,50 10,40 C10,30 15,10 30,10 Z" fill="white" stroke="gray" stroke-width="1"/></svg>');
        }
        .hidden-cell {
            visibility: hidden;
        }
    </style>
</head>
<body>
    <h1>세균전 관세전쟁</h1>
    
    <div class="game-container">
        <div class="board" id="board"></div>
        
        <div class="panel">
            <div id="turnInfo">게임 시작</div>
            <div>
                <span id="usaScore">미국: 1</span> | 
                <span id="chinaScore">중국: 1</span>
            </div>
            <div id="turnCounter">턴: 1/25</div>
            <div id="message"></div>
            <button id="restartBtn">게임 재시작</button>
            
            <div id="gameRules">
                <strong>게임 규칙:</strong>
                <ul>
                    <li>각 플레이어는 자신의 차례에 인접한 셀에 말을 놓을 수 있습니다.</li>
                    <li>상대방 말과 접촉하면 상대방 말이 자신의 말로 바뀝니다.</li>
                    <li><strong>한번 말을 놓은 곳에는 다시 말을 놓을 수 없습니다.</strong></li>
                    <li>최대 턴이 지나거나, 모든 셀이 점령되거나, 한 플레이어의 점수가 0이 되면 게임이 종료됩니다.</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="modal" id="mapModal">
        <div class="panel" style="width: 350px;">
            <h2>맵 선택</h2>
            <div class="map-selection">
                <div class="map-option selected" data-map="standard">
                    <div class="map-preview map-preview-5x5"></div>
                    <span>5x5 기본</span>
                </div>
                <div class="map-option" data-map="large">
                    <div class="map-preview map-preview-8x8"></div>
                    <span>8x8 큰맵</span>
                </div>
                <div class="map-option" data-map="usa">
                    <div class="map-preview map-preview-usa"></div>
                    <span>미국 맵</span>
                </div>
                <div class="map-option" data-map="china">
                    <div class="map-preview map-preview-china"></div>
                    <span>중국 맵</span>
                </div>
            </div>
            <p>플레이할 국가를 선택하세요:</p>
            <button id="selectUSA">미국</button>
            <button id="selectChina">중국</button>
        </div>
    </div>
    
    <div class="modal" id="resultModal" style="display: none;">
        <div class="panel">
            <h2 id="resultTitle">게임 종료!</h2>
            <p id="resultDesc"></p>
            <button id="newGameBtn">새 게임</button>
        </div>
    </div>

    <script>
        // 게임 상태
        const game = {
            board: [], // 보드 상태 (usa, china, wall, 또는 빈칸)
            visitedCells: [], // 방문한 셀 (true, false)
            size: { width: 5, height: 5 }, // 기본 맵 크기
            currentPlayer: 'usa',
            humanPlayer: '',
            computerPlayer: '',
            scores: { usa: 1, china: 1 },
            turnCount: 1,
            maxTurns: 25, // 최대 턴 수
            lastMove: { x: -1, y: -1 },  // 마지막 이동 위치
            moveHistory: [],              // 이동 기록
            mapType: 'standard',          // 맵 타입 (standard, large, usa, china)
            activeCells: []               // 활성화된 셀 (미국, 중국 맵에서 사용)
        };

        // 맵 설정
        const mapConfigs = {
            standard: {
                width: 5,
                height: 5,
                cellSize: 55,
                wallCount: { min: 2, max: 4 },
                maxTurns: 25
            },
            large: {
                width: 8,
                height: 8,
                cellSize: 45,
                wallCount: { min: 4, max: 8 },
                maxTurns: 64
            },
            usa: {
                width: 10,
                height: 8,
                cellSize: 40,
                wallCount: { min: 3, max: 6 },
                maxTurns: 50
            },
            china: {
                width: 10,
                height: 9,
                cellSize: 40,
                wallCount: { min: 3, max: 6 },
                maxTurns: 50
            }
        };

        // 미국 맵 형태 (1은 활성 셀, 0은 비활성 셀)
        const usaMapTemplate = [
            [0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,0,0,0],
            [0,0,0,0,0,0,0,0,0,0]
        ];

        // 중국 맵 형태 (1은 활성 셀, 0은 비활성 셀)
        const chinaMapTemplate = [
            [0,0,0,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,1,1,0,0],
            [0,0,0,1,1,1,1,0,0,0]
        ];

        // DOM 요소
        const boardEl = document.getElementById('board');
        const turnInfoEl = document.getElementById('turnInfo');
        const usaScoreEl = document.getElementById('usaScore');
        const chinaScoreEl = document.getElementById('chinaScore');
        const turnCounterEl = document.getElementById('turnCounter');
        const messageEl = document.getElementById('message');
        const mapModalEl = document.getElementById('mapModal');
        const resultModalEl = document.getElementById('resultModal');
        const resultTitleEl = document.getElementById('resultTitle');
        const resultDescEl = document.getElementById('resultDesc');

        // 이벤트 리스너
        document.getElementById('selectUSA').addEventListener('click', () => selectCountry('usa'));
        document.getElementById('selectChina').addEventListener('click', () => selectCountry('china'));
        document.getElementById('restartBtn').addEventListener('click', showMapModal);
        document.getElementById('newGameBtn').addEventListener('click', showMapModal);

        // 맵 옵션 선택 이벤트 리스너 추가
        document.querySelectorAll('.map-option').forEach(option => {
            option.addEventListener('click', function() {
                // 모든 옵션에서 selected 클래스 제거
                document.querySelectorAll('.map-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                // 클릭한 옵션에 selected 클래스 추가
                this.classList.add('selected');
                
                // 선택된 맵 타입 저장
                game.mapType = this.dataset.map;
            });
        });

        // 맵 모달 표시
        function showMapModal() {
            // 기본 맵 선택
            document.querySelectorAll('.map-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.querySelector(`.map-option[data-map="standard"]`).classList.add('selected');
            game.mapType = 'standard';
            
            mapModalEl.style.display = 'flex';
            resultModalEl.style.display = 'none';
        }

        // 국가 선택
        function selectCountry(country) {
            game.humanPlayer = country;
            game.computerPlayer = country === 'usa' ? 'china' : 'usa';
            
            // 선택된 맵 타입 적용
            const config = mapConfigs[game.mapType];
            game.size = { width: config.width, height: config.height };
            game.maxTurns = config.maxTurns;
            
            // 타이틀 업데이트
            document.title = `세균전 관세전쟁 ${config.width}x${config.height}`;
            
            mapModalEl.style.display = 'none';
            initGame();
            
            // 컴퓨터 차례일 경우
            if (game.currentPlayer === game.computerPlayer) {
                setTimeout(computerTurn, 1000);
            }
        }

        // 게임 초기화
        function initGame() {
            const config = mapConfigs[game.mapType];
            
            // 보드 초기화
            game.board = Array(config.height).fill().map(() => Array(config.width).fill(''));
            
            // 방문한 셀 초기화 (모두 false로 설정)
            game.visitedCells = Array(config.height).fill().map(() => Array(config.width).fill(false));
            
            // 활성 셀 초기화
            game.activeCells = Array(config.height).fill().map(() => Array(config.width).fill(true));
            
            // 맵 타입에 따른 활성 셀 설정
            if (game.mapType === 'usa') {
                for (let y = 0; y < config.height; y++) {
                    for (let x = 0; x < config.width; x++) {
                        game.activeCells[y][x] = usaMapTemplate[y][x] === 1;
                        if (!game.activeCells[y][x]) {
                            game.visitedCells[y][x] = true; // 비활성 셀은 방문한 것으로 표시
                        }
                    }
                }
            } else if (game.mapType === 'china') {
                for (let y = 0; y < config.height; y++) {
                    for (let x = 0; x < config.width; x++) {
                        game.activeCells[y][x] = chinaMapTemplate[y][x] === 1;
                        if (!game.activeCells[y][x]) {
                            game.visitedCells[y][x] = true; // 비활성 셀은 방문한 것으로 표시
                        }
                    }
                }
            }
            
            // 초기 포지션 설정 (맵 타입에 따라 다르게)
            if (game.mapType === 'standard') {
                // 기본 맵은 기존 방식대로 한 개씩만 배치
                game.board[0][0] = 'usa';
                game.board[config.height-1][config.width-1] = 'china';
                game.visitedCells[0][0] = true;
                game.visitedCells[config.height-1][config.width-1] = true;
                
                // 점수 초기화 (각 1개씩)
                game.scores = { usa: 1, china: 1 };
            } else if (game.mapType === 'large') {
                // 8x8 맵의 경우 두 개씩 배치 (대각선으로)
                game.board[0][0] = 'usa';
                game.board[0][config.width-1] = 'china';
                game.visitedCells[0][0] = true;
                game.visitedCells[0][config.width-1] = true;
                
                game.board[config.height-1][0] = 'china';
                game.board[config.height-1][config.width-1] = 'usa';
                game.visitedCells[config.height-1][0] = true;
                game.visitedCells[config.height-1][config.width-1] = true;
                
                // 점수 초기화 (각 2개씩)
                game.scores = { usa: 2, china: 2 };
            } else if (game.mapType === 'usa' || game.mapType === 'china') {
                // 특수 맵의 경우 X자 형태로 배치
                let activeCellsList = [];
                
                // 활성 셀 목록 생성
                for (let y = 0; y < config.height; y++) {
                    for (let x = 0; x < config.width; x++) {
                        if (game.activeCells[y][x]) {
                            activeCellsList.push({x, y});
                        }
                    }
                }
                
                // 맵의 네 모서리에 가까운 활성 셀 찾기
                let topLeft = null, topRight = null, bottomLeft = null, bottomRight = null;
                let minTLDist = Infinity, minTRDist = Infinity, minBLDist = Infinity, minBRDist = Infinity;
                
                for (const cell of activeCellsList) {
                    // 왼쪽 상단까지의 거리
                    const tlDist = Math.sqrt(cell.x * cell.x + cell.y * cell.y);
                    // 오른쪽 상단까지의 거리
                    const trDist = Math.sqrt((config.width - 1 - cell.x) * (config.width - 1 - cell.x) + cell.y * cell.y);
                    // 왼쪽 하단까지의 거리
                    const blDist = Math.sqrt(cell.x * cell.x + (config.height - 1 - cell.y) * (config.height - 1 - cell.y));
                    // 오른쪽 하단까지의 거리
                    const brDist = Math.sqrt((config.width - 1 - cell.x) * (config.width - 1 - cell.x) + (config.height - 1 - cell.y) * (config.height - 1 - cell.y));
                    
                    if (tlDist < minTLDist) {
                        minTLDist = tlDist;
                        topLeft = cell;
                    }
                    if (trDist < minTRDist) {
                        minTRDist = trDist;
                        topRight = cell;
                    }
                    if (blDist < minBLDist) {
                        minBLDist = blDist;
                        bottomLeft = cell;
                    }
                    if (brDist < minBRDist) {
                        minBRDist = brDist;
                        bottomRight = cell;
                    }
                }
                
                // X자 형태로 배치 (미국과 중국이 대각선으로 마주보게)
                if (topLeft && bottomRight && topRight && bottomLeft) {
                    game.board[topLeft.y][topLeft.x] = 'usa';
                    game.board[bottomRight.y][bottomRight.x] = 'usa';
                    game.visitedCells[topLeft.y][topLeft.x] = true;
                    game.visitedCells[bottomRight.y][bottomRight.x] = true;
                    
                    game.board[topRight.y][topRight.x] = 'china';
                    game.board[bottomLeft.y][bottomLeft.x] = 'china';
                    game.visitedCells[topRight.y][topRight.x] = true;
                    game.visitedCells[bottomLeft.y][bottomLeft.x] = true;
                    
                    // 점수 초기화 (각 2개씩)
                    game.scores = { usa: 2, china: 2 };
                } else {
                    // 예상치 못한 상황에 대비한 기본 배치
                    const centerX = Math.floor(config.width / 2);
                    const centerY = Math.floor(config.height / 2);
                    
                    game.board[centerY-1][centerX-1] = 'usa';
                    game.board[centerY+1][centerX+1] = 'usa';
                    game.visitedCells[centerY-1][centerX-1] = true;
                    game.visitedCells[centerY+1][centerX+1] = true;
                    
                    game.board[centerY-1][centerX+1] = 'china';
                    game.board[centerY+1][centerX-1] = 'china';
                    game.visitedCells[centerY-1][centerX+1] = true;
                    game.visitedCells[centerY+1][centerX-1] = true;
                    
                    // 점수 초기화 (각 2개씩)
                    game.scores = { usa: 2, china: 2 };
                }
            }
            
            // 맵 타입에 따른 벽 배치
            const wallCount = Math.floor(Math.random() * 
                (config.wallCount.max - config.wallCount.min + 1)) + config.wallCount.min;
            placeRandomWalls(wallCount);
            
            // 게임 상태 초기화
            game.currentPlayer = 'usa';
            game.turnCount = 1;
            game.lastMove = { x: -1, y: -1 };
            game.moveHistory = [];
            
            // UI 업데이트
            renderBoard();
            updateInfo();
            
            // 결과 모달 숨기기
            resultModalEl.style.display = 'none';
            messageEl.textContent = '';
        }

        // 랜덤 벽 배치
        function placeRandomWalls(count) {
            let wallsPlaced = 0;
            let attempts = 0;
            const maxAttempts = 100; // 무한 루프 방지
            
            while (wallsPlaced < count && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * game.size.width);
                const y = Math.floor(Math.random() * game.size.height);
                
                // 초기 위치나 이미 벽이 있는 곳, 비활성 셀은 제외
                if (!game.activeCells[y][x] || 
                    game.board[y][x] === 'usa' || 
                    game.board[y][x] === 'china' || 
                    game.board[y][x] === 'wall') {
                    continue;
                }
                
                // 벽 배치
                game.board[y][x] = 'wall';
                game.visitedCells[y][x] = true; // 벽도 방문한 셀로 표시
                wallsPlaced++;
            }
        }

        // 보드 렌더링
        function renderBoard() {
            boardEl.innerHTML = '';
            const config = mapConfigs[game.mapType];
            
            // 보드 스타일 설정
            boardEl.style.gridTemplateColumns = `repeat(${config.width}, ${config.cellSize}px)`;
            boardEl.style.gridTemplateRows = `repeat(${config.height}, ${config.cellSize}px)`;
            
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    const cell = document.createElement('div');
                    
                    // 셀 스타일 설정
                    cell.style.width = `${config.cellSize}px`;
                    cell.style.height = `${config.cellSize}px`;
                    
                    // 활성 셀인지 확인
                    if (!game.activeCells[y][x]) {
                        cell.className = 'hidden-cell';
                        boardEl.appendChild(cell);
                        continue;
                    }
                    
                    cell.className = 'cell';
                    
                    const value = game.board[y][x];
                    if (value === 'usa') {
                        cell.classList.add('usa');
                    } else if (value === 'china') {
                        cell.classList.add('china');
                    } else if (value === 'wall') {
                        cell.classList.add('wall');
                    } else if (game.visitedCells[y][x]) {
                        // 빈 셀이지만 방문한 경우
                        cell.classList.add('visited');
                    }
                    
                    // 마지막 이동 위치 표시
                    if (x === game.lastMove.x && y === game.lastMove.y) {
                        cell.classList.add('lastMove');
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    boardEl.appendChild(cell);
                }
            }
        }

        // 게임 정보 업데이트
        function updateInfo() {
            turnInfoEl.textContent = `${game.currentPlayer === 'usa' ? '미국' : '중국'}의 턴`;
            usaScoreEl.textContent = `미국: ${game.scores.usa}`;
            chinaScoreEl.textContent = `중국: ${game.scores.china}`;
            turnCounterEl.textContent = `턴: ${game.turnCount}/${game.maxTurns}`;
        }
        
        // 셀 클릭 처리
        function handleCellClick(x, y) {
            if (game.currentPlayer !== game.humanPlayer) {
                return;
            }
            
            // 이미 방문한 셀인지 확인
            if (game.visitedCells[y][x]) {
                messageEl.textContent = '이미 방문한 곳입니다. 다른 곳을 선택하세요.';
                return;
            }
            
            const value = game.board[y][x];
            
            // 벽이나 자기 영역은 선택 불가
            if (value === 'wall' || value === game.currentPlayer) {
                return;
            }
            
// 인접한 셀 확인
            if (!hasAdjacentCell(x, y, game.currentPlayer)) {
                messageEl.textContent = '인접한 칸에만 놓을 수 있습니다.';
                return;
            }
            
            // 빈 셀이나 상대방 영역 점령
            if (value === '' || value === game.computerPlayer) {
                // 점수 계산을 위한 상대방 셀 흡수 개수 확인
                const capturedCells = countAdjacentOpponentCells(x, y);
                
                // 상대방 영역이면 점수 조정
                if (value === game.computerPlayer) {
                    game.scores[game.computerPlayer]--;
                }
                
                // 선택한 셀 점령
                game.board[y][x] = game.currentPlayer;
                game.scores[game.currentPlayer]++;
                
                // 방문한 셀로 표시
                game.visitedCells[y][x] = true;
                
                // 세균전 방식으로 주변 상대방 셀 흡수
                absorbAdjacentCells(x, y);
                
                // 마지막 이동 위치 기록
                game.lastMove = { x, y };
                
                // 이동 기록 추가
                game.moveHistory.push({ x, y, player: game.currentPlayer });
                
                if (capturedCells > 0) {
                    messageEl.textContent = `${capturedCells}개의 상대방 말을 흡수했습니다!`;
                } else {
                    messageEl.textContent = '';
                }
                
                endTurn();
            }
        }

        // 인접한 셀 확인
        function hasAdjacentCell(x, y, player) {
            // 상하좌우 4방향 확인
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < game.size.width && ny >= 0 && ny < game.size.height) {
                    if (game.board[ny][nx] === player) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // 주변 상대방 셀 개수 세기
        function countAdjacentOpponentCells(x, y) {
            const opponent = game.currentPlayer === 'usa' ? 'china' : 'usa';
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 상하좌우 4방향
            let count = 0;
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // 범위 확인
                if (nx >= 0 && nx < game.size.width && ny >= 0 && ny < game.size.height) {
                    // 상대방 셀만 카운트
                    if (game.board[ny][nx] === opponent) {
                        count++;
                    }
                }
            }
            
            return count;
        }

        // 주변 상대방 셀 흡수 (세균전 방식 - 접촉하면 흡수)
        function absorbAdjacentCells(x, y) {
            const opponent = game.currentPlayer === 'usa' ? 'china' : 'usa';
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 상하좌우 4방향
            let capturedCells = 0;
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // 범위 확인
                if (nx >= 0 && nx < game.size.width && ny >= 0 && ny < game.size.height) {
                    // 상대방 셀만 변경
                    if (game.board[ny][nx] === opponent) {
                        game.board[ny][nx] = game.currentPlayer;
                        game.scores[game.currentPlayer]++;
                        game.scores[opponent]--;
                        capturedCells++;
                    }
                }
            }
            
            return capturedCells;
        }

        // 턴 종료
        function endTurn() {
            // 점수를 재계산
            recalculateScores();
            
            // 턴 수 체크 - 최대 턴에 도달했거나 한 플레이어의 점수가 0이면 게임 종료
            if (game.turnCount >= game.maxTurns || game.scores.usa <= 0 || game.scores.china <= 0) {
                gameOver();
                return;
            }
            
            // 플레이어 변경
            game.currentPlayer = game.currentPlayer === 'usa' ? 'china' : 'usa';
            
            // 턴 수 증가 (미국 턴일 때)
            if (game.currentPlayer === 'usa') {
                game.turnCount++;
            }
            
            // UI 업데이트
            renderBoard();
            updateInfo();
            
            // 현재 플레이어가 이동할 수 있는지 확인
            const currentPlayerCanMove = hasValidMove(game.currentPlayer);
            
            // 현재 플레이어가 이동할 수 없고, 상대도 이동할 수 없으면 게임 종료
            if (!currentPlayerCanMove) {
                const opponent = game.currentPlayer === 'usa' ? 'china' : 'usa';
                const opponentCanMove = hasValidMove(opponent);
                
                if (!opponentCanMove) {
                    // 둘 다 이동할 수 없으면 게임 종료
                    messageEl.textContent = '모든 이동이 완료되었습니다...';
                    setTimeout(gameOver, 1000);
                    return;
                }
                
                messageEl.textContent = '이동할 곳이 없습니다. 턴을 넘깁니다.';
                // 상대방 턴으로
                endTurn();
                return;
            }
            
            // 컴퓨터 차례일 경우
            if (game.currentPlayer === game.computerPlayer) {
                setTimeout(computerTurn, 1000);
            }
        }

        // 이동 가능한 위치가 있는지 확인
        function hasValidMove(player) {
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    // 방문하지 않은 셀이고, 빈 셀이거나 상대방 영역인 경우
                    if (game.activeCells[y][x] && !game.visitedCells[y][x] && 
                        (game.board[y][x] === '' || game.board[y][x] === (player === 'usa' ? 'china' : 'usa')) && 
                        hasAdjacentCell(x, y, player)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 보드가 가득 찼는지 확인 (더 이상 이동할 수 없는지)
        function isBoardFull() {
            // 각 플레이어가 이동 가능한 칸이 남아있는지 확인
            return !hasValidMove('usa') && !hasValidMove('china');
        }

        // 점수 재계산
        function recalculateScores() {
            const scores = { usa: 0, china: 0 };
            
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    if (game.board[y][x] === 'usa') {
                        scores.usa++;
                    } else if (game.board[y][x] === 'china') {
                        scores.china++;
                    }
                }
            }
            
            game.scores = scores;
        }

        // 게임 종료
        function gameOver() {
            // 최종 점수 재계산
            recalculateScores();
            
            let winner = '';
            if (game.scores.usa > game.scores.china) {
                winner = 'usa';
            } else if (game.scores.china > game.scores.usa) {
                winner = 'china';
            }
            // 동점인 경우는 winner를 설정하지 않음 (무승부)
            
            let reason = "";
            if (game.turnCount >= game.maxTurns) {
                reason = "25턴이 종료되었습니다. ";
            } else if (isBoardFull()) {
                reason = "모든 셀이 점령되었습니다. ";
            } else if (game.scores.usa <= 0 || game.scores.china <= 0) {
                reason = "한 국가가 완전히 패배했습니다. ";
            }
            
            if (winner) {
                resultTitleEl.textContent = `${winner === 'usa' ? '미국' : '중국'} 승리!`;
            } else {
                resultTitleEl.textContent = '무승부!';
            }
            
            resultDescEl.textContent = `${reason}최종 점수 - 미국: ${game.scores.usa}, 중국: ${game.scores.china}`;
            resultModalEl.style.display = 'flex';
        }

        // 컴퓨터 턴
        function computerTurn() {
            if (game.currentPlayer !== game.computerPlayer) {
                return;
            }
            
            // 가능한 이동 찾기
            const validMoves = [];
            
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    // 방문하지 않은 셀이고, 빈 칸이나 상대 영역인 경우
                    if (game.activeCells[y][x] && !game.visitedCells[y][x] && 
                        (game.board[y][x] === '' || 
                         game.board[y][x] === (game.computerPlayer === 'usa' ? 'china' : 'usa')) && 
                        hasAdjacentCell(x, y, game.computerPlayer)) {
                        
                        // 점수 계산: 얼마나 많은 상대 셀을 흡수할 수 있는지
                        let absorptionScore = countAdjacentOpponentCells(x, y);
                        
                        // 기본 점수 + 흡수 점수
                        let score = 1 + absorptionScore;
                        
                        // 상대방 영역이면 추가 점수
                        if (game.board[y][x] === (game.computerPlayer === 'usa' ? 'china' : 'usa')) {
                            score += 1;
                        }

                        // 전략적 점수 조정
                        // 1. 코너나 가장자리는 가치가 높음
                        if ((x === 0 || x === game.size.width-1) && (y === 0 || y === game.size.height-1)) {
                            // 코너
                            score += 3;
                        } else if (x === 0 || x === game.size.width-1 || y === 0 || y === game.size.height-1) {
                            // 가장자리
                            score += 1;
                        }
                        
                        // 2. 게임 진행 상황에 따른 전략 변경
                        if (game.turnCount > 10) {
                            // 게임 후반에는 더 공격적으로
                            if (game.scores[game.computerPlayer] < game.scores[game.humanPlayer]) {
                                // 지고 있을 때는 더 위험한 이동도 감수
                                score += absorptionScore; // 흡수 점수 두 배로
                            }
                        }
                        
                        validMoves.push({x, y, score});
                    }
                }
            }
            
            if (validMoves.length > 0) {
                // 점수 기준 정렬
                validMoves.sort((a, b) => b.score - a.score);
                
                // 최고 점수 이동 선택 (전략적 랜덤성 추가)
                let selectedIndex = 0;
                
                // 랜덤 요소 적용
                if (Math.random() < 0.3 + (game.turnCount / 50)) {
                    // 턴이 진행될수록 랜덤성 증가
                    const randomFactor = Math.min(0.5, 0.3 + (game.turnCount / 50));
                    
                    if (Math.random() < randomFactor && validMoves.length > 1) {
                        // 가끔은 최고 점수가 아닌 다른 이동 선택
                        selectedIndex = Math.floor(Math.random() * Math.min(validMoves.length, 3));
                    }
                }
                
                const move = validMoves[selectedIndex];
                
                // 상대방 영역이면 점수 조정
                const opponent = game.computerPlayer === 'usa' ? 'china' : 'usa';
                if (game.board[move.y][move.x] === opponent) {
                    game.scores[opponent]--;
                }
                
                // 이동 실행
                game.board[move.y][move.x] = game.computerPlayer;
                game.scores[game.computerPlayer]++;
                
                // 방문한 셀로 표시
                game.visitedCells[move.y][move.x] = true;
                
                // 마지막 이동 위치 기록
                game.lastMove = { x: move.x, y: move.y };
                
                // 이동 기록 추가
                game.moveHistory.push({ x: move.x, y: move.y, player: game.computerPlayer });
                
                // 주변 상대방 셀 흡수
                const capturedCells = absorbAdjacentCells(move.x, move.y);
                
                if (capturedCells > 0) {
                    messageEl.textContent = `컴퓨터가 ${capturedCells}개의 말을 흡수했습니다!`;
                } else {
                    messageEl.textContent = '컴퓨터가 이동했습니다';
                }
                
                endTurn();
            } else {
                messageEl.textContent = '컴퓨터가 이동할 곳이 없습니다';
                endTurn();
            }
        }

        // 게임 시작 - 맵 선택 화면 표시
        showMapModal();
    </script>
</body>
</html>
