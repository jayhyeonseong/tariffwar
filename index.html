// 인접한 셀 확인
            if (!hasAdjacentCell(x, y, game.currentPlayer)) {
                messageEl.textContent = '인접한 칸에만 놓을 수 있습니다.';
                return;
            }
            
            // 빈 셀이나 상대방 영역 점령
            if (value === '' || value === game.computerPlayer) {
                // 점수 계산을 위한 상대방 셀 흡수 개수 확인
                const capturedCells = countAdjacentOpponentCells(x, y);
                
                // 상대방 영역이면 점수 조정
                if (value === game.computerPlayer) {
                    game.scores[game.computerPlayer]--;
                }
                
                // 선택한 셀 점령
                game.board[y][x] = game.currentPlayer;
                game.scores[game.currentPlayer]++;
                
                // 방문한 셀로 표시
                game.visitedCells[y][x] = true;
                
                // 세균전 방식으로 주변 상대방 셀 흡수
                absorbAdjacentCells(x, y);
                
                // 마지막 이동 위치 기록
                game.lastMove = { x, y };
                
                // 이동 기록 추가
                game.moveHistory.push({ x, y, player: game.currentPlayer });
                
                if (capturedCells > 0) {
                    messageEl.textContent = `${capturedCells}개의 상대방 말을 흡수했습니다!`;
                } else {
                    messageEl.textContent = '';
                }
                
                endTurn();
            }
        }

        // 인접한 셀 확인
        function hasAdjacentCell(x, y, player) {
            // 상하좌우 4방향 확인
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < game.size.width && ny >= 0 && ny < game.size.height) {
                    if (game.board[ny][nx] === player) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // 주변 상대방 셀 개수 세기
        function countAdjacentOpponentCells(x, y) {
            const opponent = game.currentPlayer === 'usa' ? 'china' : 'usa';
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 상하좌우 4방향
            let count = 0;
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // 범위 확인
                if (nx >= 0 && nx < game.size.width && ny >= 0 && ny < game.size.height) {
                    // 상대방 셀만 카운트
                    if (game.board[ny][nx] === opponent) {
                        count++;
                    }
                }
            }
            
            return count;
        }

        // 주변 상대방 셀 흡수 (세균전 방식 - 접촉하면 흡수)
        function absorbAdjacentCells(x, y) {
            const opponent = game.currentPlayer === 'usa' ? 'china' : 'usa';
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 상하좌우 4방향
            let capturedCells = 0;
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                // 범위 확인
                if (nx >= 0 && nx < game.size.width && ny >= 0 && ny < game.size.height) {
                    // 상대방 셀만 변경
                    if (game.board[ny][nx] === opponent) {
                        game.board[ny][nx] = game.currentPlayer;
                        game.scores[game.currentPlayer]++;
                        game.scores[opponent]--;
                        capturedCells++;
                    }
                }
            }
            
            return capturedCells;
        }

        // 턴 종료
        function endTurn() {
            // 점수를 재계산
            recalculateScores();
            
            // 턴 수 체크 - 최대 턴에 도달했거나 한 플레이어의 점수가 0이면 게임 종료
            if (game.turnCount >= game.maxTurns || game.scores.usa <= 0 || game.scores.china <= 0) {
                gameOver();
                return;
            }
            
            // 플레이어 변경
            game.currentPlayer = game.currentPlayer === 'usa' ? 'china' : 'usa';
            
            // 턴 수 증가 (미국 턴일 때)
            if (game.currentPlayer === 'usa') {
                game.turnCount++;
            }
            
            // UI 업데이트
            renderBoard();
            updateInfo();
            
            // 현재 플레이어가 이동할 수 있는지 확인
            const currentPlayerCanMove = hasValidMove(game.currentPlayer);
            
            // 현재 플레이어가 이동할 수 없고, 상대도 이동할 수 없으면 게임 종료
            if (!currentPlayerCanMove) {
                const opponent = game.currentPlayer === 'usa' ? 'china' : 'usa';
                const opponentCanMove = hasValidMove(opponent);
                
                if (!opponentCanMove) {
                    // 둘 다 이동할 수 없으면 게임 종료
                    messageEl.textContent = '모든 이동이 완료되었습니다...';
                    setTimeout(gameOver, 1000);
                    return;
                }
                
                messageEl.textContent = '이동할 곳이 없습니다. 턴을 넘깁니다.';
                // 상대방 턴으로
                endTurn();
                return;
            }
            
            // 컴퓨터 차례일 경우
            if (game.currentPlayer === game.computerPlayer) {
                setTimeout(computerTurn, 1000);
            }
        }

        // 이동 가능한 위치가 있는지 확인
        function hasValidMove(player) {
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    // 방문하지 않은 셀이고, 빈 셀이거나 상대방 영역인 경우
                    if (game.activeCells[y][x] && !game.visitedCells[y][x] && 
                        (game.board[y][x] === '' || game.board[y][x] === (player === 'usa' ? 'china' : 'usa')) && 
                        hasAdjacentCell(x, y, player)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // 보드가 가득 찼는지 확인 (더 이상 이동할 수 없는지)
        function isBoardFull() {
            // 각 플레이어가 이동 가능한 칸이 남아있는지 확인
            return !hasValidMove('usa') && !hasValidMove('china');
        }

        // 점수 재계산
        function recalculateScores() {
            const scores = { usa: 0, china: 0 };
            
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    if (game.board[y][x] === 'usa') {
                        scores.usa++;
                    } else if (game.board[y][x] === 'china') {
                        scores.china++;
                    }
                }
            }
            
            game.scores = scores;
        }

        // 게임 종료
        function gameOver() {
            // 최종 점수 재계산
            recalculateScores();
            
            let winner = '';
            if (game.scores.usa > game.scores.china) {
                winner = 'usa';
            } else if (game.scores.china > game.scores.usa) {
                winner = 'china';
            }
            // 동점인 경우는 winner를 설정하지 않음 (무승부)
            
            let reason = "";
            if (game.turnCount >= game.maxTurns) {
                reason = "25턴이 종료되었습니다. ";
            } else if (isBoardFull()) {
                reason = "모든 셀이 점령되었습니다. ";
            } else if (game.scores.usa <= 0 || game.scores.china <= 0) {
                reason = "한 국가가 완전히 패배했습니다. ";
            }
            
            if (winner) {
                resultTitleEl.textContent = `${winner === 'usa' ? '미국' : '중국'} 승리!`;
            } else {
                resultTitleEl.textContent = '무승부!';
            }
            
            resultDescEl.textContent = `${reason}최종 점수 - 미국: ${game.scores.usa}, 중국: ${game.scores.china}`;
            resultModalEl.style.display = 'flex';
        }

        // 컴퓨터 턴
        function computerTurn() {
            if (game.currentPlayer !== game.computerPlayer) {
                return;
            }
            
            // 가능한 이동 찾기
            const validMoves = [];
            
            for (let y = 0; y < game.size.height; y++) {
                for (let x = 0; x < game.size.width; x++) {
                    // 방문하지 않은 셀이고, 빈 칸이나 상대 영역인 경우
                    if (game.activeCells[y][x] && !game.visitedCells[y][x] && 
                        (game.board[y][x] === '' || 
                         game.board[y][x] === (game.computerPlayer === 'usa' ? 'china' : 'usa')) && 
                        hasAdjacentCell(x, y, game.computerPlayer)) {
                        
                        // 점수 계산: 얼마나 많은 상대 셀을 흡수할 수 있는지
                        let absorptionScore = countAdjacentOpponentCells(x, y);
                        
                        // 기본 점수 + 흡수 점수
                        let score = 1 + absorptionScore;
                        
                        // 상대방 영역이면 추가 점수
                        if (game.board[y][x] === (game.computerPlayer === 'usa' ? 'china' : 'usa')) {
                            score += 1;
                        }

                        // 전략적 점수 조정
                        // 1. 코너나 가장자리는 가치가 높음
                        if ((x === 0 || x === game.size.width-1) && (y === 0 || y === game.size.height-1)) {
                            // 코너
                            score += 3;
                        } else if (x === 0 || x === game.size.width-1 || y === 0 || y === game.size.height-1) {
                            // 가장자리
                            score += 1;
                        }
                        
                        // 2. 게임 진행 상황에 따른 전략 변경
                        if (game.turnCount > 10) {
                            // 게임 후반에는 더 공격적으로
                            if (game.scores[game.computerPlayer] < game.scores[game.humanPlayer]) {
                                // 지고 있을 때는 더 위험한 이동도 감수
                                score += absorptionScore; // 흡수 점수 두 배로
                            }
                        }
                        
                        validMoves.push({x, y, score});
                    }
                }
            }
            
            if (validMoves.length > 0) {
                // 점수 기준 정렬
                validMoves.sort((a, b) => b.score - a.score);
                
                // 최고 점수 이동 선택 (전략적 랜덤성 추가)
                let selectedIndex = 0;
                
                // 랜덤 요소 적용
                if (Math.random() < 0.3 + (game.turnCount / 50)) {
                    // 턴이 진행될수록 랜덤성 증가
                    const randomFactor = Math.min(0.5, 0.3 + (game.turnCount / 50));
                    
                    if (Math.random() < randomFactor && validMoves.length > 1) {
                        // 가끔은 최고 점수가 아닌 다른 이동 선택
                        selectedIndex = Math.floor(Math.random() * Math.min(validMoves.length, 3));
                    }
                }
                
                const move = validMoves[selectedIndex];
                
                // 상대방 영역이면 점수 조정
                const opponent = game.computerPlayer === 'usa' ? 'china' : 'usa';
                if (game.board[move.y][move.x] === opponent) {
                    game.scores[opponent]--;
                }
                
                // 이동 실행
                game.board[move.y][move.x] = game.computerPlayer;
                game.scores[game.computerPlayer]++;
                
                // 방문한 셀로 표시
                game.visitedCells[move.y][move.x] = true;
                
                // 마지막 이동 위치 기록
                game.lastMove = { x: move.x, y: move.y };
                
                // 이동 기록 추가
                game.moveHistory.push({ x: move.x, y: move.y, player: game.computerPlayer });
                
                // 주변 상대방 셀 흡수
                const capturedCells = absorbAdjacentCells(move.x, move.y);
                
                if (capturedCells > 0) {
                    messageEl.textContent = `컴퓨터가 ${capturedCells}개의 말을 흡수했습니다!`;
                } else {
                    messageEl.textContent = '컴퓨터가 이동했습니다';
                }
                
                endTurn();
            } else {
                messageEl.textContent = '컴퓨터가 이동할 곳이 없습니다';
                endTurn();
            }
        }

        // 게임 시작 - 맵 선택 화면 표시
        showMapModal();
    </script>
</body>
</html>
